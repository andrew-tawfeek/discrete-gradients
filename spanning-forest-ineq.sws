
def apply(L,fn):
    res = []
    for elt in L:
        res = res + [fn(elt)]
    return res

#######

#tests where the statement holds (in terms of rank) for a simplicial complex K
def test(K):
    co_K = K.chain_complex()
    D = co_K.differential(dim(K))
    M = Matroid(D)
    Ms1 = M/[1]
    Ms2 = M/[2]
    Ms1s2 = M/[1,2]
    #now the inequality stuff
    LHS = len(Ms1.bases())*len(Ms2.bases())
    RHS = len(Ms1s2.bases())*len(M.bases())
    if LHS < RHS:
        return K.cells()
    else:
        print("Complex does not fail.")
        print(str(LHS) + ">=" + str(RHS))
        print("")



#tests num-many random complexes on n vertices in dim d, min (n,d) = (5,2)-ish
def bigtest(n,d,num):
    i = 0
    while i < num:
        i = i + 1
        K = simplicial_complexes.RandomComplex(n,d)
        test(K)
        print("")


#returns a Polymake compatible output for visualizing the polytope of a matroid M
def polymatroid(M):
    P = M.independence_matroid_polytope()
    print("$p = new Polytope(POINTS=>" + str([[1] + list(x) for x in list(P.vertices())]) + ");")
    print("$p->VISUAL;")


#returns a Polymake compatible output for visualizing the polytope of a SIMPLICIAL matroid of a complex K
def polysimpmatroid(K):
    co_K = K.chain_complex()
    D = co_K.differential(dim(K))
    M = Matroid(D)
    polymatroid(M)
